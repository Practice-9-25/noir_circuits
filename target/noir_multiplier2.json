{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"15533318811319980570","abi":{"parameters":[{"name":"public_merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"public_nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"public_recipient","type":{"kind":"field"},"visibility":"public"},{"name":"note_amount","type":{"kind":"field"},"visibility":"private"},{"name":"note_owner_pubkey","type":{"kind":"field"},"visibility":"private"},{"name":"note_owner_privkey","type":{"kind":"field"},"visibility":"private"},{"name":"note_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_path","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_path_indices","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"actual_tree_depth","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"571882728685147810":{"error_kind":"string","string":"Merkle root mismatch"},"5809420918115032802":{"error_kind":"string","string":"Nullifier mismatch"},"14917170307547230473":{"error_kind":"string","string":"Invalid pubkey-privkey pair"}}},"bytecode":"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","debug_symbols":"tZjNTutIEIXfxessuv76h1cZjVCAcBUpCigXRhoh3v3a+BwDC1sorbvhVOJ0uc9X1d3Gb8PD4e711+3x/Pj0e7j55224uxxPp+Ov29PT/f7l+HQev3173w38ePtyORzGr4Yv18dRz/vL4fwy3JxfT6fd8N/+9Prxo9/P+/OHvuwv49W0Gw7nh1HHhI/H02GK3nefo9P60FYUgyVZXsbH9wSynsCCCVy+jC/fxuv6eNXakEAt6VoGW88gkhcPUuOaORTJnEOxtJYhNuZQinEOpa26yBuF8ECCFvWK8ZL0s5I5rvHQEishTVc9pK055LpUQtNqN6XOdhLp7ifR7obanMXPOkq8u6UkOntqK8EPm2rTRn9XiflSjqJrXbWVQZVbpGhe7Uvt7Uvd6ohcOQfNzVZTbPWlfaI0XS2oWmdHbHJodeEQV3H42crQ3L0ytHQ39uYs+htby9LYlvI1je1FmCFaXctgm/VYytHiugTal8CE1TS13gRXMbClDlavsxCFCVpbTVA6txer3cvKWvey8tS5vXjqXpebNn62LrfK6b5scm31tHDvLKdHdzm9f5f00lvO/m3W/+42m2WZRPbvy/Pf8dP+/nj59m/ZkIabsQHk469O+HaDzeKzxDSZ3ZDH6ow/KbPUse7jNNq0DY2jE1SgCjWoQwOaoQVaocinU76xoCpQhRp0yjeWSwOaoWM+n8bXeQfSNqulqbtHlbmVTaEG9TmvBTRDC7TO+a3N6gkq8/1coTbfzx0a8309Q8t8P6/QNucP+A34DfgNm+8T8BvwG3m+X8BvwG/Ab4bfLFD4zfCb4TfDb4bfDL8ZfjP8Fvgt8Fvgt8Bvgd8CvwV+C/wW+C3wW+G3wm+F3wq/FX4r/Fb4rfBb4bfCb4PfBr8Nfhv8Nvht8Nvgt8Fvg98Gv5ISAzgeFzcDeJbkDOB6XPUM4FtSZQDnIomBMFAGcC/iDIIBAIgUBkAgAgaigCAqDIBB1BgAhGgwyAwKA8AQJQ0jDSMNIw0jDSMNIw0jDSMNIw0jDScNJw0nDScNJw0nDScNJw0nDSeNII0gjSCNII0gjSCNII0gjSCNII1MGpk0Mmlk0sikkUkjk0YmjUwamTQKaRTSKKRRSKOQRiGNQhqFNAppFNKopFFJo5JGJY1KGpU0KmlU0qikUUmjkUYjjUYajTQaaTTSaKTRSKORRgMNTTwEEk+BxGMggYYmHgSJJ0ECDU08CxIPgwQaKqChIgxAQ8UYOI+gYJAZFAagoQIaqokBaKgqA9BQdQagoZoZgIZqZUAaRhpGGrYciqRhpGGkYaRhpGGkYaThpOGk4aThpOGk4aThpOGk4aThpBGkEaQRpBGkEaQRpBGkEaQRpDGtwZD36fHnctzfnQ54sfz4er7/8p755f9nXuGb6OfL0/3h4fVymB5+Pq6Nj0N/AA==","file_map":{"50":{"source":"use poseidon::poseidon2::Poseidon2;\nglobal TREE_DEPTH_MAX: u32 = 16;\n\nfn recompute_root(\n    mut current: Field,\n    siblings: [Field; TREE_DEPTH_MAX],\n    indices: [Field; TREE_DEPTH_MAX],\n    actual_depth: Field,\n) -> Field {\n    for i in 0..TREE_DEPTH_MAX {\n        if i < actual_depth as u32 {\n            if indices[i] == 1 {\n                current = Poseidon2::hash([siblings[i], current], 2);\n            } else {\n                current = Poseidon2::hash([current, siblings[i]], 2);\n            }\n        }\n    }\n    current\n}\n\nfn main(\n    // Public inputs\n    public_merkle_root: pub Field,\n    public_nullifier: pub Field,\n    public_recipient: pub Field,\n    // Private inputs (witness values)\n    note_amount: Field, \n    note_owner_pubkey: Field,\n    note_owner_privkey: Field,\n    note_nonce: Field,\n    merkle_path: [Field; TREE_DEPTH_MAX],\n    merkle_path_indices: [Field; TREE_DEPTH_MAX],\n    actual_tree_depth: Field,\n) {\n    let computed_commitment = Poseidon2::hash([note_amount, note_owner_pubkey, note_nonce], 3);\n\n    let computed_nullifier = Poseidon2::hash([note_owner_privkey, note_nonce], 2);\n\n    assert(computed_nullifier == public_nullifier, \"Nullifier mismatch\");\n\n    let derived_pub = Poseidon2::hash([note_owner_privkey], 1);\n\n    assert(derived_pub == note_owner_pubkey, \"Invalid pubkey-privkey pair\");\n\n\n    // let recomputed_root = compute_merkle_root(computed_commitment, leaf_index, merkle_path);\n    let recomputed_root: Field = recompute_root(\n        computed_commitment,\n        merkle_path,\n        merkle_path_indices,\n        actual_tree_depth,\n    );\n\n    assert(recomputed_root == public_merkle_root, \"Merkle root mismatch\");\n}\n\n// #[test]\n// fn test_valid_nullifier_and_merkle_root_depth2() {\n\n//     let privkey = 5;\n//     let pubkey = poseidon1([privkey]);\n//     let amount = 1;\n//     let nonce = 7;\n\n//     let commitment = poseidon3([amount, pubkey, nonce]);\n\n//     let nullifier = poseidon2([privkey, nonce]);\n\n//     let sibling = 0; // ZERO leaf\n//     let root = poseidon2([commitment, sibling]); // leaf layer\n//     let root = poseidon2([root, 0]); // top layer\n\n//     // path: sibling=0, indices=false\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [\n//         false, false, false, false, false, false, false, false, false, false, false, false, false,\n//         false, false, false,\n//     ];\n\n//     main(\n//         root,\n//         nullifier,\n//         999,\n//         amount,\n//         pubkey,\n//         privkey,\n//         nonce,\n//         path,\n//         indices,\n//         0,\n//         2,\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_invalid_nullifier() {\n//     let privkey = 5;\n//     let pubkey = poseidon1([privkey]);\n//     let amount = 1;\n//     let nonce = 7;\n\n//     let commitment = poseidon3([amount, pubkey, nonce]);\n\n//     // Wrong nullifier: use wrong privkey\n//     let nullifier = poseidon2([42, nonce]);\n\n//     let sibling = 0;\n//     let root = poseidon2([commitment, sibling]);\n//     let root = poseidon2([root, 0]);\n\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [\n//         false, false, false, false, false, false, false, false, false, false, false, false, false,\n//         false, false, false,\n//     ];\n\n//     // should fail due to nullifier mismatch\n//     main(\n//         root,\n//         nullifier,\n//         999,\n//         amount,\n//         pubkey,\n//         privkey,\n//         nonce,\n//         path,\n//         indices,\n//         0,\n//         2,\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_invalid_pubkey() {\n//     let privkey = 5;\n//     let pubkey = 123; // wrong pubkey\n//     let amount = 1;\n//     let nonce = 7;\n\n//     let commitment = poseidon3([amount, pubkey, nonce]);\n//     let nullifier = poseidon2([privkey, nonce]);\n\n//     let sibling = 0;\n//     let root = poseidon2([commitment, sibling]);\n//     let root = poseidon2([root, 0]);\n\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [\n//         false, false, false, false, false, false, false, false, false, false, false, false, false,\n//         false, false, false,\n//     ];\n\n//     // should fail as derived_pub != pubkey\n//     main(\n//         root,\n//         nullifier,\n//         999,\n//         amount,\n//         pubkey,\n//         privkey,\n//         nonce,\n//         path,\n//         indices,\n//         0,\n//         2,\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_wrong_merkle_root() {\n//     let privkey = 5;\n//     let pubkey = poseidon1([privkey]);\n//     let amount = 1;\n//     let nonce = 7;\n\n//     let commitment = poseidon3([amount, pubkey, nonce]);\n//     let nullifier = poseidon2([privkey, nonce]);\n\n//     let sibling = 0;\n//     let root = poseidon2([commitment, sibling]);\n//     let root = poseidon2([root, 0]);\n\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [\n//         false, false, false, false, false, false, false, false, false, false, false, false, false,\n//         false, false, false,\n//     ];\n\n//     // given Wrong public_merkle_root\n//     main(\n//         root + 1,\n//         nullifier,\n//         999,\n//         amount,\n//         pubkey,\n//         privkey,\n//         nonce,\n//         path,\n//         indices,\n//         0,\n//         2,\n//     );\n// }\n\n// #[test]\n// fn test_merkle_proof_depth1_left_leaf() {\n//     let leaf = 5;\n//     let sibling = 10;\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [false, false, false, false, false, false, false, false,\n//                    false, false, false, false, false, false, false, false];\n//     let root = poseidon2([leaf, sibling]);\n//     let recomputed = recompute_root(leaf, path, indices, 1);\n//     assert(root == recomputed);\n// }\n\n// #[test]\n// fn test_merkle_proof_depth1_right_leaf() {\n//     let leaf = 7;\n//     let sibling = 3;\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [true, false, false, false, false, false, false, false,\n//                    false, false, false, false, false, false, false, false];\n//     let root = poseidon2([sibling, leaf]); // sibling left, leaf right\n//     let recomputed = recompute_root(leaf, path, indices, 1);\n//     assert(root == recomputed);\n// }\n\n// #[test]\n// fn test_merkle_proof_depth2_left_child() {\n//     let leaf = 11;\n//     let sib1 = 22; // sibling at depth 1\n//     let sib2 = 33; // sibling at depth 2\n//     let path = [sib1, sib2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [false, true, false, false, false, false, false, false,\n//                    false, false, false, false, false, false, false, false];\n//     // depth 1: leaf left, sib1 right\n//     let node1 = poseidon2([leaf, sib1]);\n//     // depth 2: sib2 left, node1 right\n//     let root = poseidon2([sib2, node1]);\n//     let recomputed = recompute_root(leaf, path, indices, 2);\n//     assert(root==recomputed);\n// }\n\n// #[test]\n// fn test_merkle_proof_depth4_mixed_indices() {\n//     let leaf = 99;\n//     let path = [1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [false, true, false, true, false, false, false, false,\n//                    false, false, false, false, false, false, false, false];\n\n//     let n1 = poseidon2([leaf, 1]);   // depth 1 (leaf left, sib right)\n//     let n2 = poseidon2([2, n1]);     // depth 2 (sib left, current right)\n//     let n3 = poseidon2([n2, 3]);     // depth 3 (current left, sib right)\n//     let root = poseidon2([4, n3]);   // depth 4 (sib left, current right)\n//     let recomputed = recompute_root(leaf, path, indices, 4);\n//     assert(root==recomputed);\n// }\n","path":"/Users/sanjaysirangi/Desktop/zkether2/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/sanjaysirangi/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}