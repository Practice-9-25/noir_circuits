{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"13446117695091495299","abi":{"parameters":[{"name":"public_merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"public_nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"public_recipient","type":{"kind":"field"},"visibility":"public"},{"name":"note_amount","type":{"kind":"field"},"visibility":"private"},{"name":"note_owner_pubkey","type":{"kind":"field"},"visibility":"private"},{"name":"note_owner_privkey","type":{"kind":"field"},"visibility":"private"},{"name":"note_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_path","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_path_indices","type":{"kind":"array","length":16,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"actual_tree_depth","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"571882728685147810":{"error_kind":"string","string":"Merkle root mismatch"},"5809420918115032802":{"error_kind":"string","string":"Nullifier mismatch"},"14917170307547230473":{"error_kind":"string","string":"Invalid pubkey-privkey pair"}}},"bytecode":"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","debug_symbols":"tZjLbuM6EET/Ress2M0m2cyvXFwETuIMDBhO4LEHGATz70OFVU6ykGCYmFWVHzqg2Efy43163j6efzzsDi+vP6f7/96nx+Nuv9/9eNi/Pm1Ou9dDe/b9z93Ehw+n43bbnpq+vN6Oetsct4fTdH847/d306/N/vzxpp9vm8NHnjbH9mq4m7aH55YN+LLbb+f25+7z6LB8qAQXHC1i6QJI3wmyTIhJATDJn8eXb8fr8vGqXgHQGHSJEFfOQbJezsHTLWsokrmGEsMSIa2soZTINZS6eBZ5mVAtAVCT33C8BL3sQsjplnOogZOQqovnsGZT2wYSVOuiTWFQJ5Fhn0SHhVpdxXVGiQ0rJWnQqTXAlVKtnsa4VWqXjVCXJavWCNGNBFNbIuiol7pmRHbepzXXuIhY8zJ+bmXUxYFqHDRidR+qX/Yh3bQP110ZmoevDC3DYq+uYlxsi37RsoRbxM56ueGWtCh2XJ0HjdB6I0DGAFE4ivh1G68HmPAUTPNNK/iU2hbHEPPg3SGW4ati9mXwqoh18O6wBrjyslo9jesuq7Vxpsi9TMWXxmlxcJxmw+O08W+UNvqV0sa/U9q//VJZ8uUu6eH7T5T/26PN0+747WfVJHm6b4dI6eEzo2XtqQEp85JaahtSe59GpDUB2no0zTeklhlZkI6sPWNAClKREWlI8OLMa6ONBenI2tPCrF1L6fccU2TjWVufWZfXEjIjwTPwDLwUkNK5SZGxc5MhU+enjCydmxwJXgYvC1KRsXOzIVPn5owsnZsdWTu3BCR4BbwSkYZMnVsysnRucWTtXA9I6VxXJHgOnick5uGlc92RtXNrQErnVkXGzq2YRwWvglcxj4p51Nq5EgILJtwuMxbMWIKxYMrt+mMBt/10Z8FkRAILZi2iLJh2+5XPgnmLZBZMXMRZSFaSVViUBXMXNRZMXjSzYPaizoLpSwwsJEeSY2QxFjggMbPAAonOAg/EAgtMEFMWko1kSyyZBT6IOQuMkBRY4IQkZYEVkoyF5ERy4gQTJ5joRqYbmW5kupHpRqYbmW5kupFJziRnTrBwgoVuFLpR6EahG4VuFLpR6EahG4VkJ9k5QecEnW443XC64XTD6YbTDacblW5UkivJlROsnGClG5VuVLpR6UaFGxoCC9zQoCwgazCWxJJZ4IYGZ4EbKoEFbqgoC9xQMRaShWQpLM4CN1QDC9xQVRa4oWoscEM1s5SPz8z5g/a42zzut/gL8uV8ePryj+Tp9xtf4X+Wb8fXp+3z+bidP2Y/XmsfvH8B","file_map":{"50":{"source":"use poseidon::poseidon2::Poseidon2;\nglobal TREE_DEPTH_MAX: u32 = 16;\n\nfn recompute_root(\n    mut current: Field,\n    siblings: [Field; TREE_DEPTH_MAX],\n    indices: [bool; TREE_DEPTH_MAX],\n    actual_depth: Field,\n) -> Field {\n    for i in 0..TREE_DEPTH_MAX {\n        if i < actual_depth as u32 {\n            if indices[i] {\n                // sibling left, current right\n                current = Poseidon2::hash([siblings[i], current], 2);\n            } else {\n                // current left, sibling right\n                current = Poseidon2::hash([current, siblings[i]], 2);\n            }\n        }\n    }\n    current\n}\n\nfn main(\n    // Public inputs\n    public_merkle_root: pub Field,\n    public_nullifier: pub Field,\n    public_recipient: pub Field,\n    // Private inputs (witness values)\n    note_amount: Field,\n    note_owner_pubkey: Field,\n    note_owner_privkey: Field,\n    note_nonce: Field,\n    merkle_path: [Field; TREE_DEPTH_MAX],\n    merkle_path_indices: [bool; TREE_DEPTH_MAX],\n    leaf_index: Field,\n    actual_tree_depth: Field,\n) {\n    let computed_commitment = Poseidon2::hash([note_amount, note_owner_pubkey, note_nonce], 3);\n\n    let computed_nullifier = Poseidon2::hash([note_owner_privkey, note_nonce], 2);\n\n    assert(computed_nullifier == public_nullifier, \"Nullifier mismatch\");\n\n    // Ownership check (placeholder for real EC check)\n    let derived_pub = Poseidon2::hash([note_owner_privkey], 1);\n\n    assert(derived_pub == note_owner_pubkey, \"Invalid pubkey-privkey pair\");\n\n    // let recomputed_root = compute_merkle_root(computed_commitment, leaf_index, merkle_path);\n    let recomputed_root = recompute_root(\n        computed_commitment,\n        merkle_path,\n        merkle_path_indices,\n        actual_tree_depth,\n    );\n\n    assert(recomputed_root == public_merkle_root, \"Merkle root mismatch\");\n}\n\n// #[test]\n// fn test_valid_nullifier_and_merkle_root_depth2() {\n\n//     let privkey = 5;\n//     let pubkey = poseidon1([privkey]);\n//     let amount = 1;\n//     let nonce = 7;\n\n//     let commitment = poseidon3([amount, pubkey, nonce]);\n\n//     let nullifier = poseidon2([privkey, nonce]);\n\n//     let sibling = 0; // ZERO leaf\n//     let root = poseidon2([commitment, sibling]); // leaf layer\n//     let root = poseidon2([root, 0]); // top layer\n\n//     // path: sibling=0, indices=false\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [\n//         false, false, false, false, false, false, false, false, false, false, false, false, false,\n//         false, false, false,\n//     ];\n\n//     main(\n//         root,\n//         nullifier,\n//         999,\n//         amount,\n//         pubkey,\n//         privkey,\n//         nonce,\n//         path,\n//         indices,\n//         0,\n//         2,\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_invalid_nullifier() {\n//     let privkey = 5;\n//     let pubkey = poseidon1([privkey]);\n//     let amount = 1;\n//     let nonce = 7;\n\n//     let commitment = poseidon3([amount, pubkey, nonce]);\n\n//     // Wrong nullifier: use wrong privkey\n//     let nullifier = poseidon2([42, nonce]);\n\n//     let sibling = 0;\n//     let root = poseidon2([commitment, sibling]);\n//     let root = poseidon2([root, 0]);\n\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [\n//         false, false, false, false, false, false, false, false, false, false, false, false, false,\n//         false, false, false,\n//     ];\n\n//     // should fail due to nullifier mismatch\n//     main(\n//         root,\n//         nullifier,\n//         999,\n//         amount,\n//         pubkey,\n//         privkey,\n//         nonce,\n//         path,\n//         indices,\n//         0,\n//         2,\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_invalid_pubkey() {\n//     let privkey = 5;\n//     let pubkey = 123; // wrong pubkey\n//     let amount = 1;\n//     let nonce = 7;\n\n//     let commitment = poseidon3([amount, pubkey, nonce]);\n//     let nullifier = poseidon2([privkey, nonce]);\n\n//     let sibling = 0;\n//     let root = poseidon2([commitment, sibling]);\n//     let root = poseidon2([root, 0]);\n\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [\n//         false, false, false, false, false, false, false, false, false, false, false, false, false,\n//         false, false, false,\n//     ];\n\n//     // should fail as derived_pub != pubkey\n//     main(\n//         root,\n//         nullifier,\n//         999,\n//         amount,\n//         pubkey,\n//         privkey,\n//         nonce,\n//         path,\n//         indices,\n//         0,\n//         2,\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_wrong_merkle_root() {\n//     let privkey = 5;\n//     let pubkey = poseidon1([privkey]);\n//     let amount = 1;\n//     let nonce = 7;\n\n//     let commitment = poseidon3([amount, pubkey, nonce]);\n//     let nullifier = poseidon2([privkey, nonce]);\n\n//     let sibling = 0;\n//     let root = poseidon2([commitment, sibling]);\n//     let root = poseidon2([root, 0]);\n\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [\n//         false, false, false, false, false, false, false, false, false, false, false, false, false,\n//         false, false, false,\n//     ];\n\n//     // given Wrong public_merkle_root\n//     main(\n//         root + 1,\n//         nullifier,\n//         999,\n//         amount,\n//         pubkey,\n//         privkey,\n//         nonce,\n//         path,\n//         indices,\n//         0,\n//         2,\n//     );\n// }\n\n// #[test]\n// fn test_merkle_proof_depth1_left_leaf() {\n//     let leaf = 5;\n//     let sibling = 10;\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [false, false, false, false, false, false, false, false,\n//                    false, false, false, false, false, false, false, false];\n//     let root = poseidon2([leaf, sibling]);\n//     let recomputed = recompute_root(leaf, path, indices, 1);\n//     assert(root == recomputed);\n// }\n\n// #[test]\n// fn test_merkle_proof_depth1_right_leaf() {\n//     let leaf = 7;\n//     let sibling = 3;\n//     let path = [sibling, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [true, false, false, false, false, false, false, false,\n//                    false, false, false, false, false, false, false, false];\n//     let root = poseidon2([sibling, leaf]); // sibling left, leaf right\n//     let recomputed = recompute_root(leaf, path, indices, 1);\n//     assert(root == recomputed);\n// }\n\n// #[test]\n// fn test_merkle_proof_depth2_left_child() {\n//     let leaf = 11;\n//     let sib1 = 22; // sibling at depth 1\n//     let sib2 = 33; // sibling at depth 2\n//     let path = [sib1, sib2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [false, true, false, false, false, false, false, false,\n//                    false, false, false, false, false, false, false, false];\n//     // depth 1: leaf left, sib1 right\n//     let node1 = poseidon2([leaf, sib1]);\n//     // depth 2: sib2 left, node1 right\n//     let root = poseidon2([sib2, node1]);\n//     let recomputed = recompute_root(leaf, path, indices, 2);\n//     assert(root==recomputed);\n// }\n\n// #[test]\n// fn test_merkle_proof_depth4_mixed_indices() {\n//     let leaf = 99;\n//     let path = [1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//     let indices = [false, true, false, true, false, false, false, false,\n//                    false, false, false, false, false, false, false, false];\n\n//     let n1 = poseidon2([leaf, 1]);   // depth 1 (leaf left, sib right)\n//     let n2 = poseidon2([2, n1]);     // depth 2 (sib left, current right)\n//     let n3 = poseidon2([n2, 3]);     // depth 3 (current left, sib right)\n//     let root = poseidon2([4, n3]);   // depth 4 (sib left, current right)\n//     let recomputed = recompute_root(leaf, path, indices, 4);\n//     assert(root==recomputed);\n// }\n","path":"/Users/sanjaysirangi/Desktop/zkether2/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/sanjaysirangi/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}