"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AztecClientBackend = exports.UltraHonkBackend = exports.UltraHonkVerifierBackend = exports.AztecClientBackendError = void 0;
const index_js_1 = require("./index.js");
const raw_buffer_js_1 = require("../types/raw_buffer.js");
const index_js_2 = require("../proof/index.js");
const api_types_js_1 = require("../cbind/generated/api_types.js");
const pako_1 = require("pako");
const buffer_1 = require("buffer");
const msgpackr_1 = require("msgpackr");
class AztecClientBackendError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.AztecClientBackendError = AztecClientBackendError;
function getProofSettingsFromOptions(options) {
    return {
        ipaAccumulation: false,
        oracleHashType: options?.keccak || options?.keccakZK ? 'keccak' : (options?.starknet || options?.starknetZK ? 'starknet' : 'poseidon2'),
        // TODO no current way to target non-zk poseidon2 hash
        disableZk: options?.keccak || options?.starknet ? true : false,
        optimizedSolidityVerifier: false,
    };
}
class UltraHonkVerifierBackend {
    constructor(backendOptions = { threads: 1 }, circuitOptions = { recursive: false }) {
        this.backendOptions = backendOptions;
        this.circuitOptions = circuitOptions;
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await index_js_1.Barretenberg.new(this.backendOptions);
            const honkRecursion = true;
            await api.initSRSForCircuitSize(0);
            this.api = api;
        }
    }
    async verifyProof(proofData, options) {
        await this.instantiate();
        const proofFrs = [];
        for (let i = 0; i < proofData.proof.length; i += 32) {
            proofFrs.push(proofData.proof.slice(i, i + 32));
        }
        const { verified } = await this.api.circuitVerify({
            verificationKey: proofData.verificationKey,
            publicInputs: proofData.publicInputs.map(index_js_2.hexToUint8Array),
            proof: proofFrs,
            settings: getProofSettingsFromOptions(options),
        });
        return verified;
    }
    destroy() {
        if (!this.api) {
            return Promise.resolve();
        }
        return this.api.destroy();
    }
}
exports.UltraHonkVerifierBackend = UltraHonkVerifierBackend;
class UltraHonkBackend {
    constructor(acirBytecode, backendOptions = { threads: 1 }, circuitOptions = { recursive: false }) {
        this.backendOptions = backendOptions;
        this.circuitOptions = circuitOptions;
        this.acirUncompressedBytecode = acirToUint8Array(acirBytecode);
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await index_js_1.Barretenberg.new(this.backendOptions);
            const honkRecursion = true;
            await api.acirInitSRS(this.acirUncompressedBytecode, this.circuitOptions.recursive, honkRecursion);
            this.api = api;
        }
    }
    async generateProof(compressedWitness, options) {
        await this.instantiate();
        const witness = (0, pako_1.ungzip)(compressedWitness);
        const { proof, publicInputs } = await this.api.circuitProve({
            witness,
            circuit: {
                name: 'circuit',
                bytecode: buffer_1.Buffer.from(this.acirUncompressedBytecode),
                verificationKey: buffer_1.Buffer.from([]), // Empty VK - lower performance.
            },
            settings: getProofSettingsFromOptions(options)
        });
        console.log(`Generated proof for circuit with ${publicInputs.length} public inputs and ${proof.length} fields.`);
        // We return ProofData as a flat buffer and an array of strings to match the current ProofData class.
        const flatProof = new Uint8Array(proof.length * 32);
        proof.forEach((fr, i) => {
            flatProof.set(fr, i * 32);
        });
        return { proof: flatProof, publicInputs: publicInputs.map(index_js_2.uint8ArrayToHex) };
    }
    async verifyProof(proofData, options) {
        await this.instantiate();
        const proofFrs = [];
        for (let i = 0; i < proofData.proof.length; i += 32) {
            proofFrs.push(proofData.proof.slice(i, i + 32));
        }
        // TODO reconsider API - computing the VK at this point is not optimal
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
            },
            settings: getProofSettingsFromOptions(options),
        });
        const { verified } = await this.api.circuitVerify({
            verificationKey: vkResult.bytes,
            publicInputs: proofData.publicInputs.map(index_js_2.hexToUint8Array),
            proof: proofFrs,
            settings: getProofSettingsFromOptions(options),
        });
        return verified;
    }
    async getVerificationKey(options) {
        await this.instantiate();
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: buffer_1.Buffer.from(this.acirUncompressedBytecode),
            },
            settings: getProofSettingsFromOptions(options),
        });
        return vkResult.bytes;
    }
    /** @description Returns a solidity verifier */
    async getSolidityVerifier(vk) {
        await this.instantiate();
        const vkBuf = vk ?? (await this.api.acirWriteVkUltraKeccakHonk(this.acirUncompressedBytecode));
        return await this.api.acirHonkSolidityVerifier(this.acirUncompressedBytecode, new raw_buffer_js_1.RawBuffer(vkBuf));
    }
    // TODO(https://github.com/noir-lang/noir/issues/5661): Update this to handle Honk recursive aggregation in the browser once it is ready in the backend itself
    async generateRecursiveProofArtifacts(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _proof, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _numOfPublicInputs) {
        await this.instantiate();
        // TODO(https://github.com/noir-lang/noir/issues/5661): This needs to be updated to handle recursive aggregation.
        // There is still a proofAsFields method but we could consider getting rid of it as the proof itself
        // is a list of field elements.
        // UltraHonk also does not have public inputs directly prepended to the proof and they are still instead
        // inserted at an offset.
        // const proof = reconstructProofWithPublicInputs(proofData);
        // const proofAsFields = (await this.api.acirProofAsFieldsUltraHonk(proof)).slice(numOfPublicInputs);
        // TODO: perhaps we should put this in the init function. Need to benchmark
        // TODO how long it takes.
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: buffer_1.Buffer.from(this.acirUncompressedBytecode),
            },
            settings: getProofSettingsFromOptions({}),
        });
        // Convert VK bytes to field elements (32-byte chunks)
        const vkAsFields = [];
        for (let i = 0; i < vkResult.bytes.length; i += 32) {
            const chunk = vkResult.bytes.slice(i, i + 32);
            vkAsFields.push((0, index_js_2.uint8ArrayToHex)(chunk));
        }
        return {
            // TODO(https://github.com/noir-lang/noir/issues/5661)
            proofAsFields: [],
            vkAsFields,
            // We use an empty string for the vk hash here as it is unneeded as part of the recursive artifacts
            // The user can be expected to hash the vk inside their circuit to check whether the vk is the circuit
            // they expect
            vkHash: (0, index_js_2.uint8ArrayToHex)(vkResult.hash)
        };
    }
    async destroy() {
        if (!this.api) {
            return;
        }
        await this.api.destroy();
    }
}
exports.UltraHonkBackend = UltraHonkBackend;
class AztecClientBackend {
    constructor(acirBuf, options = { threads: 1 }) {
        this.acirBuf = acirBuf;
        this.options = options;
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await index_js_1.Barretenberg.new(this.options);
            await api.initSRSClientIVC();
            this.api = api;
        }
    }
    async prove(witnessBuf, vksBuf = []) {
        if (vksBuf.length !== 0 && this.acirBuf.length !== witnessBuf.length) {
            throw new AztecClientBackendError('Witness and bytecodes must have the same stack depth!');
        }
        if (vksBuf.length !== 0 && vksBuf.length !== witnessBuf.length) {
            // NOTE: we allow 0 as an explicit 'I have no VKs'. This is a deprecated feature.
            throw new AztecClientBackendError('Witness and VKs must have the same stack depth!');
        }
        await this.instantiate();
        // Queue IVC start with the number of circuits
        this.api.clientIvcStart({ numCircuits: this.acirBuf.length });
        // Queue load and accumulate for each circuit
        for (let i = 0; i < this.acirBuf.length; i++) {
            const bytecode = this.acirBuf[i];
            const witness = witnessBuf[i] || buffer_1.Buffer.from([]);
            const vk = vksBuf[i] || buffer_1.Buffer.from([]);
            const functionName = `unknown_wasm_${i}`;
            // Load the circuit
            this.api.clientIvcLoad({
                circuit: {
                    name: functionName,
                    bytecode: buffer_1.Buffer.from(bytecode),
                    verificationKey: buffer_1.Buffer.from(vk),
                }
            });
            // Accumulate with witness
            this.api.clientIvcAccumulate({
                witness: buffer_1.Buffer.from(witness),
            });
        }
        // Generate the proof (and wait for all previous steps to finish)
        const proveResult = await this.api.clientIvcProve({});
        // The API currently expects a msgpack-encoded API.
        const proof = new msgpackr_1.Encoder({ useRecords: false }).encode((0, api_types_js_1.fromClientIVCProof)(proveResult.proof));
        // Generate the VK
        const vkResult = await this.api.clientIvcComputeIvcVk({ circuit: {
                name: 'hiding',
                bytecode: this.acirBuf[this.acirBuf.length - 1],
            } });
        // Note: Verification may not work correctly until we properly serialize the proof
        if (!(await this.verify(proof, vkResult.bytes))) {
            throw new AztecClientBackendError('Failed to verify the private (ClientIVC) transaction proof!');
        }
        return [proof, vkResult.bytes];
    }
    async verify(proof, vk) {
        await this.instantiate();
        const result = await this.api.clientIvcVerify({
            proof: (0, api_types_js_1.toClientIVCProof)(new msgpackr_1.Decoder({ useRecords: false }).decode(proof)),
            vk: buffer_1.Buffer.from(vk),
        });
        return result.valid;
    }
    async gates() {
        await this.instantiate();
        const circuitSizes = [];
        for (const buf of this.acirBuf) {
            const gates = await this.api.clientIvcStats({
                circuit: {
                    name: 'circuit',
                    bytecode: buf,
                },
                includeGatesPerOpcode: false
            });
            circuitSizes.push(gates.circuitSize);
        }
        return circuitSizes;
    }
    async destroy() {
        if (!this.api) {
            return;
        }
        await this.api.destroy();
    }
}
exports.AztecClientBackend = AztecClientBackend;
// Converts bytecode from a base64 string to a Uint8Array
function acirToUint8Array(base64EncodedBytecode) {
    const compressedByteCode = base64Decode(base64EncodedBytecode);
    return (0, pako_1.ungzip)(compressedByteCode);
}
// Since this is a simple function, we can use feature detection to
// see if we are in the nodeJs environment or the browser environment.
function base64Decode(input) {
    if (typeof buffer_1.Buffer !== 'undefined') {
        // Node.js environment
        const b = buffer_1.Buffer.from(input, 'base64');
        return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
    }
    else if (typeof atob === 'function') {
        // Browser environment
        return Uint8Array.from(atob(input), c => c.charCodeAt(0));
    }
    else {
        throw new Error('No implementation found for base64 decoding.');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9iYXJyZXRlbmJlcmcvYmFja2VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx5Q0FBMEU7QUFDMUUsMERBQW1EO0FBQ25ELGdEQU8yQjtBQUMzQixrRUFBdUY7QUFDdkYsK0JBQThCO0FBQzlCLG1DQUFnQztBQUNoQyx1Q0FBNEM7QUFFNUMsTUFBYSx1QkFBd0IsU0FBUSxLQUFLO0lBQ2hELFlBQVksT0FBZTtRQUN6QixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakIsQ0FBQztDQUNGO0FBSkQsMERBSUM7QUE0QkQsU0FBUywyQkFBMkIsQ0FDbEMsT0FBaUM7SUFFakMsT0FBTztRQUNMLGVBQWUsRUFBRSxLQUFLO1FBQ3RCLGNBQWMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxJQUFJLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO1FBQ3ZJLHNEQUFzRDtRQUN0RCxTQUFTLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUs7UUFDOUQseUJBQXlCLEVBQUUsS0FBSztLQUNqQyxDQUFDO0FBQ0osQ0FBQztBQUVELE1BQWEsd0JBQXdCO0lBR25DLFlBQ1ksaUJBQWlDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUMvQyxpQkFBaUMsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFO1FBRHJELG1CQUFjLEdBQWQsY0FBYyxDQUFpQztRQUMvQyxtQkFBYyxHQUFkLGNBQWMsQ0FBdUM7SUFDOUQsQ0FBQztJQUNKLGNBQWM7SUFDTixLQUFLLENBQUMsV0FBVztRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2QsTUFBTSxHQUFHLEdBQUcsTUFBTSx1QkFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDeEQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDO1lBQzNCLE1BQU0sR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRW5DLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2pCLENBQUM7SUFDSCxDQUFDO0lBRUQsS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFzRCxFQUFFLE9BQWlDO1FBQ3pHLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXpCLE1BQU0sUUFBUSxHQUFpQixFQUFFLENBQUM7UUFDbEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztZQUNwRCxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNsRCxDQUFDO1FBQ0QsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUM7WUFDaEQsZUFBZSxFQUFFLFNBQVMsQ0FBQyxlQUFlO1lBQzFDLFlBQVksRUFBRSxTQUFTLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQywwQkFBZSxDQUFDO1lBQ3pELEtBQUssRUFBRSxRQUFRO1lBQ2YsUUFBUSxFQUFFLDJCQUEyQixDQUFDLE9BQU8sQ0FBQztTQUMvQyxDQUFDLENBQUM7UUFDSCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBQ0QsT0FBTztRQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDZCxPQUFPLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMzQixDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzVCLENBQUM7Q0FDRjtBQXZDRCw0REF1Q0M7QUFFRCxNQUFhLGdCQUFnQjtJQVMzQixZQUNFLFlBQW9CLEVBQ1YsaUJBQWlDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUMvQyxpQkFBaUMsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFO1FBRHJELG1CQUFjLEdBQWQsY0FBYyxDQUFpQztRQUMvQyxtQkFBYyxHQUFkLGNBQWMsQ0FBdUM7UUFFL0QsSUFBSSxDQUFDLHdCQUF3QixHQUFHLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFDRCxjQUFjO0lBQ04sS0FBSyxDQUFDLFdBQVc7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNkLE1BQU0sR0FBRyxHQUFHLE1BQU0sdUJBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ3hELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQztZQUMzQixNQUFNLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRW5HLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2pCLENBQUM7SUFDSCxDQUFDO0lBRUQsS0FBSyxDQUFDLGFBQWEsQ0FBQyxpQkFBNkIsRUFBRSxPQUFpQztRQUNsRixNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUV6QixNQUFNLE9BQU8sR0FBRyxJQUFBLGFBQU0sRUFBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQzFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQztZQUMxRCxPQUFPO1lBQ1AsT0FBTyxFQUFFO2dCQUNQLElBQUksRUFBRSxTQUFTO2dCQUNmLFFBQVEsRUFBRSxlQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQztnQkFDcEQsZUFBZSxFQUFFLGVBQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsZ0NBQWdDO2FBQ25FO1lBQ0QsUUFBUSxFQUFFLDJCQUEyQixDQUFDLE9BQU8sQ0FBQztTQUMvQyxDQUFDLENBQUM7UUFDSCxPQUFPLENBQUMsR0FBRyxDQUFDLG9DQUFvQyxZQUFZLENBQUMsTUFBTSxzQkFBc0IsS0FBSyxDQUFDLE1BQU0sVUFBVSxDQUFDLENBQUM7UUFFakgscUdBQXFHO1FBQ3JHLE1BQU0sU0FBUyxHQUFHLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDcEQsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN0QixTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDNUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsWUFBWSxDQUFDLEdBQUcsQ0FBQywwQkFBZSxDQUFDLEVBQUUsQ0FBQztJQUMvRSxDQUFDO0lBRUQsS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFvQixFQUFFLE9BQWlDO1FBQ3ZFLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXpCLE1BQU0sUUFBUSxHQUFpQixFQUFFLENBQUM7UUFDbEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztZQUNwRCxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNsRCxDQUFDO1FBQ0Qsc0VBQXNFO1FBQ3RFLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQztZQUMvQyxPQUFPLEVBQUU7Z0JBQ1AsSUFBSSxFQUFFLFNBQVM7Z0JBQ2YsUUFBUSxFQUFFLElBQUksQ0FBQyx3QkFBd0I7YUFDeEM7WUFDRCxRQUFRLEVBQUUsMkJBQTJCLENBQUMsT0FBTyxDQUFDO1NBQy9DLENBQUMsQ0FBQztRQUNILE1BQU0sRUFBQyxRQUFRLEVBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO1lBQzlDLGVBQWUsRUFBRSxRQUFRLENBQUMsS0FBSztZQUMvQixZQUFZLEVBQUUsU0FBUyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsMEJBQWUsQ0FBQztZQUN6RCxLQUFLLEVBQUUsUUFBUTtZQUNmLFFBQVEsRUFBRSwyQkFBMkIsQ0FBQyxPQUFPLENBQUM7U0FDL0MsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUVELEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxPQUFpQztRQUN4RCxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUV6QixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUM7WUFDL0MsT0FBTyxFQUFFO2dCQUNQLElBQUksRUFBRSxTQUFTO2dCQUNmLFFBQVEsRUFBRSxlQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQzthQUNyRDtZQUNELFFBQVEsRUFBRSwyQkFBMkIsQ0FBQyxPQUFPLENBQUM7U0FDL0MsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDO0lBQ3hCLENBQUM7SUFFRCwrQ0FBK0M7SUFDL0MsS0FBSyxDQUFDLG1CQUFtQixDQUFDLEVBQWU7UUFDdkMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDekIsTUFBTSxLQUFLLEdBQUcsRUFBRSxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7UUFDL0YsT0FBTyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLElBQUkseUJBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3RHLENBQUM7SUFFRCw4SkFBOEo7SUFDOUosS0FBSyxDQUFDLCtCQUErQjtJQUNuQyw2REFBNkQ7SUFDN0QsTUFBa0I7SUFDbEIsNkRBQTZEO0lBQzdELGtCQUEwQjtRQUUxQixNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN6QixpSEFBaUg7UUFDakgsb0dBQW9HO1FBQ3BHLCtCQUErQjtRQUMvQix3R0FBd0c7UUFDeEcseUJBQXlCO1FBQ3pCLDZEQUE2RDtRQUM3RCxxR0FBcUc7UUFFckcsMkVBQTJFO1FBQzNFLDBCQUEwQjtRQUMxQixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUM7WUFDL0MsT0FBTyxFQUFFO2dCQUNQLElBQUksRUFBRSxTQUFTO2dCQUNmLFFBQVEsRUFBRSxlQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQzthQUNyRDtZQUNELFFBQVEsRUFBRSwyQkFBMkIsQ0FBQyxFQUFFLENBQUM7U0FDMUMsQ0FBQyxDQUFDO1FBRUgsc0RBQXNEO1FBQ3RELE1BQU0sVUFBVSxHQUFhLEVBQUUsQ0FBQztRQUNoQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDO1lBQ25ELE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDOUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFBLDBCQUFlLEVBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDO1FBRUQsT0FBTztZQUNMLHNEQUFzRDtZQUN0RCxhQUFhLEVBQUUsRUFBRTtZQUNqQixVQUFVO1lBQ1YsbUdBQW1HO1lBQ25HLHNHQUFzRztZQUN0RyxjQUFjO1lBQ2QsTUFBTSxFQUFFLElBQUEsMEJBQWUsRUFBQyxRQUFRLENBQUMsSUFBSSxDQUFDO1NBQ3ZDLENBQUM7SUFDSixDQUFDO0lBRUQsS0FBSyxDQUFDLE9BQU87UUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2QsT0FBTztRQUNULENBQUM7UUFDRCxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDM0IsQ0FBQztDQUNGO0FBakpELDRDQWlKQztBQUVELE1BQWEsa0JBQWtCO0lBUTdCLFlBQ1ksT0FBcUIsRUFDckIsVUFBMEIsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFO1FBRHhDLFlBQU8sR0FBUCxPQUFPLENBQWM7UUFDckIsWUFBTyxHQUFQLE9BQU8sQ0FBaUM7SUFDakQsQ0FBQztJQUVKLGNBQWM7SUFDTixLQUFLLENBQUMsV0FBVztRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2QsTUFBTSxHQUFHLEdBQUcsTUFBTSx1QkFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDakQsTUFBTSxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUM3QixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNqQixDQUFDO0lBQ0gsQ0FBQztJQUVELEtBQUssQ0FBQyxLQUFLLENBQUMsVUFBd0IsRUFBRSxTQUF1QixFQUFFO1FBQzdELElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEtBQUssVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3JFLE1BQU0sSUFBSSx1QkFBdUIsQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO1FBQzdGLENBQUM7UUFDRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQy9ELGlGQUFpRjtZQUNqRixNQUFNLElBQUksdUJBQXVCLENBQUMsaURBQWlELENBQUMsQ0FBQztRQUN2RixDQUFDO1FBQ0QsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFekIsOENBQThDO1FBQzlDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUU5RCw2Q0FBNkM7UUFDN0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDN0MsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqQyxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksZUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNqRCxNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksZUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN4QyxNQUFNLFlBQVksR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7WUFFekMsbUJBQW1CO1lBQ25CLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO2dCQUNyQixPQUFPLEVBQUU7b0JBQ1AsSUFBSSxFQUFFLFlBQVk7b0JBQ2xCLFFBQVEsRUFBRSxlQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztvQkFDL0IsZUFBZSxFQUFFLGVBQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2lCQUNqQzthQUNGLENBQUMsQ0FBQztZQUVILDBCQUEwQjtZQUMxQixJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDO2dCQUMzQixPQUFPLEVBQUUsZUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7YUFDOUIsQ0FBQyxDQUFDO1FBRUwsQ0FBQztRQUlELGlFQUFpRTtRQUNqRSxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RELG1EQUFtRDtRQUNuRCxNQUFNLEtBQUssR0FBRyxJQUFJLGtCQUFPLENBQUMsRUFBQyxVQUFVLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBQSxpQ0FBa0IsRUFBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUM3RixrQkFBa0I7UUFDbEIsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLEVBQUUsT0FBTyxFQUFFO2dCQUMvRCxJQUFJLEVBQUUsUUFBUTtnQkFDZCxRQUFRLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7YUFDaEQsRUFBRSxDQUFDLENBQUM7UUFHTCxrRkFBa0Y7UUFDbEYsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2hELE1BQU0sSUFBSSx1QkFBdUIsQ0FBQyw2REFBNkQsQ0FBQyxDQUFDO1FBQ25HLENBQUM7UUFDRCxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRUQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFpQixFQUFFLEVBQWM7UUFDNUMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDekIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQztZQUM1QyxLQUFLLEVBQUUsSUFBQSwrQkFBZ0IsRUFBQyxJQUFJLGtCQUFPLENBQUMsRUFBQyxVQUFVLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkUsRUFBRSxFQUFFLGVBQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1NBQ3BCLENBQUMsQ0FBQztRQUNILE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQztJQUN0QixDQUFDO0lBRUQsS0FBSyxDQUFDLEtBQUs7UUFDVCxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN6QixNQUFNLFlBQVksR0FBYSxFQUFFLENBQUM7UUFDbEMsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDL0IsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQztnQkFDMUMsT0FBTyxFQUFFO29CQUNQLElBQUksRUFBRSxTQUFTO29CQUNmLFFBQVEsRUFBRSxHQUFHO2lCQUNkO2dCQUNELHFCQUFxQixFQUFFLEtBQUs7YUFDN0IsQ0FBQyxDQUFDO1lBQ0gsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkMsQ0FBQztRQUNELE9BQU8sWUFBWSxDQUFDO0lBQ3RCLENBQUM7SUFFRCxLQUFLLENBQUMsT0FBTztRQUNYLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDZCxPQUFPO1FBQ1QsQ0FBQztRQUNELE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMzQixDQUFDO0NBQ0Y7QUE3R0QsZ0RBNkdDO0FBRUQseURBQXlEO0FBQ3pELFNBQVMsZ0JBQWdCLENBQUMscUJBQTZCO0lBQ3JELE1BQU0sa0JBQWtCLEdBQUcsWUFBWSxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDL0QsT0FBTyxJQUFBLGFBQU0sRUFBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3BDLENBQUM7QUFFRCxtRUFBbUU7QUFDbkUsc0VBQXNFO0FBQ3RFLFNBQVMsWUFBWSxDQUFDLEtBQWE7SUFDakMsSUFBSSxPQUFPLGVBQU0sS0FBSyxXQUFXLEVBQUUsQ0FBQztRQUNsQyxzQkFBc0I7UUFDdEIsTUFBTSxDQUFDLEdBQUcsZUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdkMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzlELENBQUM7U0FBTSxJQUFJLE9BQU8sSUFBSSxLQUFLLFVBQVUsRUFBRSxDQUFDO1FBQ3RDLHNCQUFzQjtRQUN0QixPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUM7U0FBTSxDQUFDO1FBQ04sTUFBTSxJQUFJLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7QUFDSCxDQUFDIn0=