"use strict";
/**
 * Unified schema compiler with integrated strategies
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaCompiler = void 0;
exports.createSharedTypesCompiler = createSharedTypesCompiler;
exports.createSyncApiCompiler = createSyncApiCompiler;
exports.createAsyncApiCompiler = createAsyncApiCompiler;
exports.createNativeApiCompiler = createNativeApiCompiler;
// Helper functions
function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.substring(1);
}
function camelCase(s) {
    return s
        .split('_')
        .map((part, index) => (index === 0 ? part.charAt(0).toLowerCase() + part.substring(1) : capitalize(part)))
        .join('');
}
function pascalCase(s) {
    return s.split('_').map(capitalize).join('');
}
class SchemaCompiler {
    constructor(config) {
        this.config = config;
        this.typeCache = new Map();
        this.functionMetadata = [];
        // WORKTODO(bbapi): AI slop fixup - redundant with typeCache, remove
        this.referencedTypes = new Set();
    }
    /**
     * Process API schema and extract function metadata
     */
    processApiSchema(commandsSchema, responsesSchema) {
        // Process types
        this.processSchema(commandsSchema);
        this.processSchema(responsesSchema);
        // Extract function metadata from named unions
        if (!Array.isArray(commandsSchema) || commandsSchema[0] !== 'named_union' ||
            !Array.isArray(responsesSchema) || responsesSchema[0] !== 'named_union') {
            throw new Error('Expected named_union schema format');
        }
        const commands = commandsSchema[1];
        const responses = responsesSchema[1];
        for (let i = 0; i < commands.length; i++) {
            const [commandName] = commands[i];
            const [responseName] = responses[i];
            this.functionMetadata.push({
                name: camelCase(commandName),
                commandType: pascalCase(commandName),
                responseType: pascalCase(responseName),
            });
        }
    }
    /**
     * Process a schema and populate type cache
     */
    processSchema(schema) {
        const key = this.getSchemaKey(schema);
        if (this.typeCache.has(key)) {
            const ret = this.typeCache.get(key);
            if (ret.typeName === 'unknown') {
                throw new Error(`Recursive schema detected at ${key}, please check your schema for circular references.`);
            }
            return ret;
        }
        this.typeCache.set(key, { typeName: 'unknown', msgpackTypeName: '' });
        const typeInfo = this.generateTypeInfo(schema);
        this.typeCache.set(key, typeInfo);
        return typeInfo;
    }
    /**
     * Generate the complete output
     */
    compile() {
        const parts = [
            '// AUTOGENERATED FILE - DO NOT EDIT',
            '',
        ];
        // Generate imports
        parts.push(...this.generateImports());
        parts.push('');
        // Generate type declarations only for 'types' mode
        if (this.config.mode === 'types') {
            const sortedTypes = Array.from(this.typeCache.values())
                .filter(t => t.declaration)
                .sort((a, b) => a.typeName.localeCompare(b.typeName));
            // Group declarations
            const typeAliases = sortedTypes.filter(t => t.declaration?.startsWith('export type') && !t.declaration?.includes('interface'));
            const publicInterfaces = sortedTypes.filter(t => t.declaration?.includes('export interface'));
            const privateInterfaces = sortedTypes.filter(t => t.declaration?.includes('interface Msgpack'));
            // Add type aliases if needed
            if (typeAliases.length > 0) {
                parts.push('// Type aliases');
                for (const type of typeAliases) {
                    parts.push(type.declaration);
                }
                parts.push('');
            }
            // Add tuple helper if needed
            if (this.needsTupleHelper()) {
                parts.push('// Tuple type for fixed-size arrays', 'type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;', 'type _TupleOf<T, N extends number, R extends unknown[]> = R[\'length\'] extends N ? R : _TupleOf<T, N, [T, ...R]>;', '', '// Helper functions', 'function mapTuple<T, S, N extends number>(tuple: Tuple<T, N>, fn: (item: T) => S): Tuple<S, N> {', '  return tuple.map(fn) as Tuple<S, N>;', '}', '');
            }
            // Add public interfaces
            if (publicInterfaces.length > 0) {
                parts.push('// Public interfaces (exported)');
                for (const type of publicInterfaces) {
                    parts.push(type.declaration, '');
                }
            }
            // Add private interfaces
            if (privateInterfaces.length > 0) {
                parts.push('// Private Msgpack interfaces (not exported)');
                for (const type of privateInterfaces) {
                    parts.push(type.declaration, '');
                }
            }
            // Add conversion functions (only for api_types.ts)
            const conversions = sortedTypes.filter(t => t.toMethod || t.fromMethod);
            if (conversions.length > 0) {
                parts.push('// Conversion functions (exported)');
                for (const type of conversions) {
                    if (type.toMethod) {
                        parts.push('export ' + type.toMethod, '');
                    }
                    if (type.fromMethod) {
                        parts.push('export ' + type.fromMethod, '');
                    }
                }
            }
            // Add BbApiBase interface
            if (this.functionMetadata.length > 0) {
                parts.push('', '// Base API interface');
                parts.push(this.generateBbApiBaseInterface());
            }
        }
        // Add API class for non-types modes
        if (this.config.mode !== 'types' && this.functionMetadata.length > 0) {
            parts.push(this.generateApiClass());
        }
        return parts.join('\n') + '\n';
    }
    getSchemaKey(schema) {
        if (typeof schema === 'string')
            return schema;
        if (Array.isArray(schema))
            return JSON.stringify(schema);
        if (typeof schema === 'object')
            return schema.__typename || JSON.stringify(schema);
        return String(schema);
    }
    needsTupleHelper() {
        return Array.from(this.typeCache.values()).some(t => t.typeName.includes('Tuple<'));
    }
    trackTypeUsage(typeName) {
        // Only track for API modes
        if (this.config.mode === 'types')
            return;
        // Extract base types from complex types
        const baseTypes = this.extractBaseTypes(typeName);
        for (const type of baseTypes) {
            // Skip built-in types
            if (['string', 'number', 'boolean', 'Uint8Array'].includes(type)) {
                continue;
            }
            this.referencedTypes.add(type);
        }
    }
    extractBaseTypes(typeName) {
        const types = [];
        // Handle arrays
        const arrayMatch = typeName.match(/^(.+)\[\]$/);
        if (arrayMatch) {
            types.push(...this.extractBaseTypes(arrayMatch[1]));
            return types;
        }
        // Handle Tuple
        const tupleMatch = typeName.match(/^Tuple<(.+),\s*\d+>$/);
        if (tupleMatch) {
            types.push(...this.extractBaseTypes(tupleMatch[1]));
            return types;
        }
        // Handle Record
        const recordMatch = typeName.match(/^Record<(.+),\s*(.+)>$/);
        if (recordMatch) {
            types.push(...this.extractBaseTypes(recordMatch[1]));
            types.push(...this.extractBaseTypes(recordMatch[2]));
            return types;
        }
        // Handle union types
        if (typeName.includes(' | ')) {
            const parts = typeName.split(' | ');
            for (const part of parts) {
                types.push(...this.extractBaseTypes(part.trim()));
            }
            return types;
        }
        // Base case - simple type
        types.push(typeName);
        return types;
    }
    generateTypeInfo(schema) {
        if (Array.isArray(schema)) {
            return this.processArraySchema(schema);
        }
        else if (typeof schema === 'string') {
            return this.processPrimitiveSchema(schema);
        }
        else if (typeof schema === 'object') {
            return this.processObjectSchema(schema);
        }
        throw new Error(`Unsupported schema type: ${schema}`);
    }
    processArraySchema(schema) {
        const [type, ...args] = schema;
        switch (type) {
            case 'array': {
                const [subtype, size] = args[0];
                const subtypeInfo = this.processSchema(subtype);
                return {
                    typeName: `Tuple<${subtypeInfo.typeName}, ${size}>`,
                    msgpackTypeName: `Tuple<${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}, ${size}>`,
                };
            }
            case 'variant': {
                const variants = args[0];
                const variantInfos = variants.map(v => this.processSchema(v));
                const typeName = variantInfos.map(v => v.typeName).join(' | ');
                const msgpackUnion = variantInfos.map(v => v.msgpackTypeName || v.typeName).join(' | ');
                return {
                    typeName,
                    msgpackTypeName: `[number, ${msgpackUnion}]`,
                };
            }
            case 'named_union': {
                const namedTypes = args[0];
                const tupleTypes = [];
                for (const [name, schemaOrName] of namedTypes) {
                    let typeInfo = this.processSchema(schemaOrName);
                    // Track usage of the type
                    this.trackTypeUsage(typeInfo.typeName);
                    tupleTypes.push(`["${name}", ${typeInfo.typeName}]`);
                }
                return {
                    typeName: tupleTypes.join(' | '),
                    msgpackTypeName: tupleTypes.join(' | '),
                };
            }
            case 'vector': {
                const [subtype] = args[0];
                if (subtype === 'unsigned char') {
                    return { typeName: 'Uint8Array' };
                }
                const subtypeInfo = this.processSchema(subtype);
                return {
                    typeName: `${subtypeInfo.typeName}[]`,
                    msgpackTypeName: `${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}[]`,
                };
            }
            case 'alias': {
                const [rawTypeName, msgpackName] = args[0];
                const typeName = pascalCase(rawTypeName);
                let targetType;
                if (msgpackName.startsWith('bin')) {
                    targetType = 'Uint8Array';
                }
                else if (['int', 'unsigned int', 'unsigned short'].includes(msgpackName)) {
                    targetType = 'number';
                }
                else {
                    throw new Error(`Unsupported alias type: ${msgpackName}`);
                }
                // Create a proper type alias declaration
                return {
                    typeName,
                    msgpackTypeName: targetType,
                    declaration: `export type ${typeName} = ${targetType};`,
                };
            }
            case 'shared_ptr': {
                const [subtype] = args[0];
                return this.processSchema(subtype);
            }
            case 'map': {
                const [keyType, valueType] = args[0];
                const keyInfo = this.processSchema(keyType);
                const valueInfo = this.processSchema(valueType);
                return {
                    typeName: `Record<${keyInfo.typeName}, ${valueInfo.typeName}>`,
                    msgpackTypeName: `Record<${keyInfo.msgpackTypeName || keyInfo.typeName}, ${valueInfo.msgpackTypeName || valueInfo.typeName}>`,
                };
            }
            default:
                throw new Error(`Unsupported array schema type: ${type}`);
        }
    }
    processPrimitiveSchema(schema) {
        switch (schema) {
            case 'bool':
                return { typeName: 'boolean' };
            case 'int':
            case 'unsigned int':
            case 'unsigned short':
            case 'unsigned long':
            case 'double':
                return { typeName: 'number' };
            case 'string':
                return { typeName: 'string' };
            case 'bin32':
                return { typeName: 'Uint8Array' };
            default:
                return { typeName: pascalCase(schema) };
        }
    }
    processObjectSchema(schema) {
        const typeName = pascalCase(schema.__typename);
        const msgpackTypeName = 'Msgpack' + typeName;
        const declaration = this.generateInterfaces(typeName, schema);
        const toMethod = this.generateToMethod(typeName, schema);
        const fromMethod = this.generateFromMethod(typeName, schema);
        return {
            typeName,
            msgpackTypeName,
            declaration,
            toMethod,
            fromMethod,
        };
    }
    getOrCreateEmptyType(typeName) {
        const key = `empty_${typeName}`;
        if (this.typeCache.has(key)) {
            return this.typeCache.get(key);
        }
        const typeInfo = {
            typeName,
            msgpackTypeName: 'Msgpack' + typeName,
            declaration: `export interface ${typeName} {}\n\ninterface Msgpack${typeName} {}`,
            toMethod: `function to${typeName}(o: Msgpack${typeName}): ${typeName} {\n  return {};\n}`,
            fromMethod: `function from${typeName}(o: ${typeName}): Msgpack${typeName} {\n  return {};\n}`,
        };
        this.typeCache.set(key, typeInfo);
        return typeInfo;
    }
    generateInterfaces(name, schema) {
        const publicInterface = this.generatePublicInterface(name, schema);
        const msgpackInterface = this.generateMsgpackInterface(name, schema);
        return publicInterface + '\n\n' + msgpackInterface;
    }
    generatePublicInterface(name, schema) {
        let result = `export interface ${name} {\n`;
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            const typeInfo = this.processSchema(value);
            // Track type usage
            this.trackTypeUsage(typeInfo.typeName);
            result += `  ${camelCase(key)}: ${typeInfo.typeName};\n`;
        }
        result += '}';
        return result;
    }
    generateMsgpackInterface(name, schema) {
        let result = `interface Msgpack${name} {\n`;
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            const typeInfo = this.processSchema(value);
            result += `  ${key}: ${typeInfo.msgpackTypeName || typeInfo.typeName};\n`;
        }
        result += '}';
        return result;
    }
    generateToMethod(name, schema) {
        const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
        if (fields.length === 0) {
            return `function to${name}(o: Msgpack${name}): ${name} {\n  return {};\n}`;
        }
        const checks = fields.map(([key]) => `  if (o.${key} === undefined) { throw new Error("Expected ${key} in ${name} deserialization"); }`).join('\n');
        const conversions = fields.map(([key, value]) => {
            const typeInfo = this.processSchema(value);
            const converter = this.generateConverter(typeInfo, `o.${key}`, 'to');
            return `    ${camelCase(key)}: ${converter},`;
        }).join('\n');
        return `function to${name}(o: Msgpack${name}): ${name} {
${checks};
  return {
${conversions}
  };
}`;
    }
    generateFromMethod(name, schema) {
        const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
        if (fields.length === 0) {
            return `function from${name}(o: ${name}): Msgpack${name} {\n  return {};\n}`;
        }
        const checks = fields.map(([key]) => `  if (o.${camelCase(key)} === undefined) { throw new Error("Expected ${camelCase(key)} in ${name} serialization"); }`).join('\n');
        const conversions = fields.map(([key, value]) => {
            const typeInfo = this.processSchema(value);
            const converter = this.generateConverter(typeInfo, `o.${camelCase(key)}`, 'from');
            return `  ${key}: ${converter},`;
        }).join('\n');
        return `function from${name}(o: ${name}): Msgpack${name} {
${checks};
  return {
${conversions}
  };
}`;
    }
    generateConverter(typeInfo, value, direction) {
        // Handle arrays/tuples
        if (typeInfo.typeName.includes('[]') || typeInfo.typeName.includes('Tuple<')) {
            const elementType = typeInfo.typeName.match(/^(.+)\[\]$/) || typeInfo.typeName.match(/^Tuple<(.+),/);
            if (elementType) {
                const isTuple = typeInfo.typeName.includes('Tuple<');
                const mapFn = isTuple ? 'mapTuple' : 'map';
                return `${value}.${mapFn}((v: any) => v)`; // Simplified for now
            }
        }
        // Handle custom types
        if (typeInfo.declaration) {
            return `${direction}${typeInfo.typeName}(${value})`;
        }
        return value;
    }
    generateImports() {
        const imports = [];
        // Base imports
        if (this.config.imports) {
            imports.push(...this.config.imports);
        }
        // For API modes, import from api_types
        if (this.config.mode !== 'types') {
            const neededImports = new Set();
            // Add types and conversion functions from function metadata
            for (const metadata of this.functionMetadata) {
                neededImports.add(metadata.commandType);
                neededImports.add(metadata.responseType);
                neededImports.add(`from${metadata.commandType}`);
                neededImports.add(`to${metadata.responseType}`);
            }
            // Add referenced types
            for (const type of this.referencedTypes) {
                neededImports.add(type);
            }
            // Add BbApiBase interface
            neededImports.add('BbApiBase');
            if (neededImports.size > 0) {
                const sortedImports = Array.from(neededImports).sort();
                // Remove duplicates
                const uniqueImports = sortedImports.filter((item, index) => sortedImports.indexOf(item) === index);
                imports.push(`import { ${uniqueImports.join(', ')} } from './api_types.js';`);
            }
        }
        return imports;
    }
    generateBbApiBaseInterface() {
        const methods = this.functionMetadata.map(m => `  ${m.name}(command: ${m.commandType}): Promise<${m.responseType}>;`).join('\n');
        return `export interface BbApiBase {
${methods}
  destroy(): Promise<void>;
}`;
    }
    generateApiClass() {
        const className = this.getApiClassName();
        const methods = this.functionMetadata.map(m => this.generateApiMethod(m)).join('\n\n');
        if (this.config.mode === 'native') {
            return this.generateNativeApiClass(methods);
        }
        // For sync API, don't implement BbApiBase since methods are synchronous
        const implementsClause = this.config.mode === 'sync' ? '' : ' implements BbApiBase';
        const msgpackCallHelper = `${this.config.mode === 'async' ? 'async ' : ''}function msgpackCall(wasm: ${this.getWasmType()}, cbind: string, input: any[]) {` +
            `  const inputBuffer = new Encoder({ useRecords: false }).pack(input);` +
            `  const encodedResult = ${this.config.mode === 'async' ? 'await ' : ''}wasm.cbindCall(cbind, inputBuffer);` +
            `  return new Decoder({ useRecords: false }).unpack(encodedResult);` +
            `}\n`;
        return (msgpackCallHelper +
            `export class ${className}${implementsClause} {
  constructor(protected wasm: ${this.getWasmType()}) {}

${methods}

  destroy(): Promise<void> {
    return this.wasm.destroy();
  }
}`);
    }
    getApiClassName() {
        switch (this.config.mode) {
            case 'sync': return 'SyncApi';
            case 'async': return 'AsyncApi';
            case 'native': return 'NativeApi';
            default: throw new Error(`Invalid mode: ${this.config.mode}`);
        }
    }
    getWasmType() {
        switch (this.config.mode) {
            case 'sync': return 'BarretenbergWasmMain';
            case 'async': return 'BarretenbergWasmMainWorker';
            default: return '';
        }
    }
    generateApiMethod(metadata) {
        const { name, commandType, responseType } = metadata;
        if (this.config.mode === 'native') {
            return `  ${name}(command: ${commandType}): Promise<${responseType}> {
    const msgpackCommand = from${commandType}(command);
    return this.sendCommand(['${metadata.commandType}', msgpackCommand]).then(([variantName, result]: [string, any]) => {
      if (variantName !== '${responseType}') {
        throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
      }
      return to${responseType}(result);
    });
  }`;
        }
        // For async mode, queue immediately and return promise
        if (this.config.mode === 'async') {
            return `  ${name}(command: ${commandType}): Promise<${responseType}> {
    const msgpackCommand = from${commandType}(command);
    return msgpackCall(this.wasm, 'bbapi', [["${capitalize(name)}", msgpackCommand]]).then(([variantName, result]: [string, any]) => {
      if (variantName !== '${responseType}') {
        throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
      }
      return to${responseType}(result);
    });
  }`;
        }
        // For sync mode, keep the synchronous behavior
        return `  ${name}(command: ${commandType}): ${responseType} {
    const msgpackCommand = from${commandType}(command);
    const [variantName, result] = msgpackCall(this.wasm, 'bbapi', [["${capitalize(name)}", msgpackCommand]]);
    if (variantName !== '${responseType}') {
      throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
    }
    return to${responseType}(result);
  }`;
    }
    generateNativeApiClass(methods) {
        return `interface NativeApiRequest {
  resolve: (value: any) => void;
  reject: (error: any) => void;
}

class StreamBuffer {
  private buffer = Buffer.alloc(0);
  private expectedLength: number | null = null;

  addData(data: Buffer): Buffer[] {
    // Create buffer to grow as needed
    const newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
    this.buffer.copy(newBuffer, 0);
    data.copy(newBuffer, this.buffer.length);
    this.buffer = newBuffer;

    const messages: Buffer[] = [];

    while (true) {
      if (this.expectedLength === null) {
        if (this.buffer.length < 4) break;
        this.expectedLength = this.buffer.readUInt32LE(0);
        this.buffer = this.buffer.subarray(4);
      }

      if (this.buffer.length < this.expectedLength) break;

      // Extract complete message
      const messageBuffer = this.buffer.subarray(0, this.expectedLength);
      messages.push(messageBuffer);
      this.buffer = this.buffer.subarray(this.expectedLength);
      this.expectedLength = null;
    }

    return messages;
  }
}

export class NativeApi implements BbApiBase {
  private decoder = new Decoder({ useRecords: false });
  private encoder = new Encoder({ useRecords: false });
  private pendingRequests: NativeApiRequest[] = [];

  private constructor(private proc: ChildProcess) {}

  static async new(bbPath = 'bb', logger = console.log): Promise<NativeApi> {
    const proc = spawn(bbPath, ['msgpack', 'run'], {
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    if (!proc.stdout || !proc.stdin) {
      throw new Error('Failed to initialize bb process');
    }

    const api = new NativeApi(proc);
    const streamBuffer = new StreamBuffer();

    proc.stdout.on('data', (data: Buffer) => {
      const messages = streamBuffer.addData(data);

      for (const messageBuffer of messages) {
        const pendingRequest = api.pendingRequests.shift();
        if (!pendingRequest) {
          throw new Error('Received response without a pending request');
        }

        try {
          const decoded = api.decoder.decode(messageBuffer);
          if (!Array.isArray(decoded) || decoded.length !== 2) {
            throw new Error(\`Invalid response format: \${JSON.stringify(decoded)}\`);
          }
          const [variantName, result] = decoded;
          pendingRequest.resolve([variantName, result]);
        } catch (error) {
          pendingRequest.reject(error);
          break;
        }
      }
    });

    proc.stderr.on('data', (data: Buffer) => {
      logger(data.toString().trim());
    });

    proc.on('error', err => {
      throw new Error(err.message);
    });
    return api;
  }

  private sendCommand(command: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.pendingRequests.push({ resolve, reject });
      const encoded = this.encoder.encode(command);

      // Write length prefix (4 bytes, little-endian)
      const lengthBuffer = Buffer.allocUnsafe(4);
      lengthBuffer.writeUInt32LE(encoded.length, 0);

      // Write length prefix followed by the encoded data
      this.proc.stdin!.write(lengthBuffer);
      this.proc.stdin!.write(encoded);
    });
  }

  async close(): Promise<void> {
    this.proc.kill();
  }

  destroy(): Promise<void> {
    return this.close();
  }

${methods}
}`;
    }
}
exports.SchemaCompiler = SchemaCompiler;
// Factory methods for creating configured compilers
function createSharedTypesCompiler() {
    return new SchemaCompiler({
        mode: 'types',
        imports: [],
    });
}
function createSyncApiCompiler() {
    return new SchemaCompiler({
        mode: 'sync',
        imports: [
            `import { BarretenbergWasmMain } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`,
            `import { Decoder, Encoder } from 'msgpackr';`,
        ],
    });
}
function createAsyncApiCompiler() {
    return new SchemaCompiler({
        mode: 'async',
        imports: [
            `import { BarretenbergWasmMainWorker } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`,
            `import { Decoder, Encoder } from 'msgpackr';`
        ],
    });
}
function createNativeApiCompiler() {
    return new SchemaCompiler({
        mode: 'native',
        imports: [
            `import { spawn, ChildProcess } from 'child_process';`,
            `import { Decoder, Encoder } from 'msgpackr';`
        ],
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hX2NvbXBpbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NiaW5kL3NjaGVtYV9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7OztBQTJ4QkgsOERBS0M7QUFFRCxzREFRQztBQUVELHdEQVFDO0FBRUQsMERBUUM7QUF2eEJELG1CQUFtQjtBQUNuQixTQUFTLFVBQVUsQ0FBQyxDQUFTO0lBQzNCLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BELENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FBQyxDQUFTO0lBQzFCLE9BQU8sQ0FBQztTQUNMLEtBQUssQ0FBQyxHQUFHLENBQUM7U0FDVixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDekcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2QsQ0FBQztBQUVELFNBQVMsVUFBVSxDQUFDLENBQVM7SUFDM0IsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUVELE1BQWEsY0FBYztJQU16QixZQUFvQixNQUFzQjtRQUF0QixXQUFNLEdBQU4sTUFBTSxDQUFnQjtRQUxsQyxjQUFTLEdBQUcsSUFBSSxHQUFHLEVBQW9CLENBQUM7UUFDeEMscUJBQWdCLEdB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