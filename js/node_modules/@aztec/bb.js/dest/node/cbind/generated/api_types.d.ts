export type Fr = Uint8Array;
export type Uint256T = Uint8Array;
export interface CircuitComputeVk {
    circuit: CircuitInputNoVK;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitComputeVk {
    circuit: MsgpackCircuitInputNoVK;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint256T[];
    hash: Uint8Array;
}
interface MsgpackCircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
    hash: Uint8Array;
}
export interface CircuitInfoResponse {
    numGates: number;
    numGatesDyadic: number;
    numAcirOpcodes: number;
    gatesPerOpcode: number[];
}
interface MsgpackCircuitInfoResponse {
    num_gates: number;
    num_gates_dyadic: number;
    num_acir_opcodes: number;
    gates_per_opcode: number[];
}
export interface CircuitInput {
    name: string;
    bytecode: Uint8Array;
    verificationKey: Uint8Array;
}
interface MsgpackCircuitInput {
    name: string;
    bytecode: Uint8Array;
    verification_key: Uint8Array;
}
export interface CircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
interface MsgpackCircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
export interface CircuitProve {
    circuit: CircuitInput;
    witness: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitProve {
    circuit: MsgpackCircuitInput;
    witness: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitProveResponse {
    publicInputs: Uint256T[];
    proof: Uint256T[];
    vk: CircuitComputeVkResponse;
}
interface MsgpackCircuitProveResponse {
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    vk: MsgpackCircuitComputeVkResponse;
}
export interface CircuitStats {
    circuit: CircuitInput;
    includeGatesPerOpcode: boolean;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitStats {
    circuit: MsgpackCircuitInput;
    include_gates_per_opcode: boolean;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerify {
    verificationKey: Uint8Array;
    publicInputs: Uint256T[];
    proof: Uint256T[];
    settings: ProofSystemSettings;
}
interface MsgpackCircuitVerify {
    verification_key: Uint8Array;
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerifyResponse {
    verified: boolean;
}
interface MsgpackCircuitVerifyResponse {
    verified: boolean;
}
export interface CircuitWriteSolidityVerifier {
    verificationKey: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitWriteSolidityVerifier {
    verification_key: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitWriteSolidityVerifierResponse {
    solidityCode: string;
}
interface MsgpackCircuitWriteSolidityVerifierResponse {
    solidity_code: string;
}
export interface ClientIvcAccumulate {
    witness: Uint8Array;
}
interface MsgpackClientIvcAccumulate {
    witness: Uint8Array;
}
export interface ClientIvcAccumulateResponse {
}
interface MsgpackClientIvcAccumulateResponse {
}
export interface ClientIvcCheckPrecomputedVk {
    circuit: CircuitInput;
}
interface MsgpackClientIvcCheckPrecomputedVk {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actualVk: Uint8Array;
}
interface MsgpackClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actual_vk: Uint8Array;
}
export interface ClientIvcComputeIvcVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeIvcVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
interface MsgpackClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
export interface ClientIvcComputeStandaloneVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeStandaloneVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Fr[];
}
interface MsgpackClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
}
export interface ClientIvcLoad {
    circuit: CircuitInput;
}
interface MsgpackClientIvcLoad {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcLoadResponse {
}
interface MsgpackClientIvcLoadResponse {
}
export interface ClientIVCProof {
    megaProof: Fr[];
    goblinProof: GoblinProof;
}
interface MsgpackClientIVCProof {
    mega_proof: Uint8Array[];
    goblin_proof: MsgpackGoblinProof;
}
export interface ClientIvcProve {
}
interface MsgpackClientIvcProve {
}
export interface ClientIvcProveResponse {
    proof: ClientIVCProof;
}
interface MsgpackClientIvcProveResponse {
    proof: MsgpackClientIVCProof;
}
export interface ClientIvcStart {
    numCircuits: number;
}
interface MsgpackClientIvcStart {
    num_circuits: number;
}
export interface ClientIvcStartResponse {
}
interface MsgpackClientIvcStartResponse {
}
export interface ClientIvcStats {
    circuit: CircuitInputNoVK;
    includeGatesPerOpcode: boolean;
}
interface MsgpackClientIvcStats {
    circuit: MsgpackCircuitInputNoVK;
    include_gates_per_opcode: boolean;
}
export interface ClientIvcStatsResponse {
    acirOpcodes: number;
    circuitSize: number;
    gatesPerOpcode: number[];
}
interface MsgpackClientIvcStatsResponse {
    acir_opcodes: number;
    circuit_size: number;
    gates_per_opcode: number[];
}
export interface ClientIvcVerify {
    proof: ClientIVCProof;
    vk: Uint8Array;
}
interface MsgpackClientIvcVerify {
    proof: MsgpackClientIVCProof;
    vk: Uint8Array;
}
export interface ClientIvcVerifyResponse {
    valid: boolean;
}
interface MsgpackClientIvcVerifyResponse {
    valid: boolean;
}
export interface ECCVMProof {
    preIpaProof: Fr[];
    ipaProof: Fr[];
}
interface MsgpackECCVMProof {
    pre_ipa_proof: Uint8Array[];
    ipa_proof: Uint8Array[];
}
export interface GoblinProof {
    mergeProof: Fr[];
    eccvmProof: ECCVMProof;
    translatorProof: Fr[];
}
interface MsgpackGoblinProof {
    merge_proof: Uint8Array[];
    eccvm_proof: MsgpackECCVMProof;
    translator_proof: Uint8Array[];
}
export interface ProofSystemSettings {
    ipaAccumulation: boolean;
    oracleHashType: string;
    disableZk: boolean;
    optimizedSolidityVerifier: boolean;
}
interface MsgpackProofSystemSettings {
    ipa_accumulation: boolean;
    oracle_hash_type: string;
    disable_zk: boolean;
    optimized_solidity_verifier: boolean;
}
export interface VkAsFields {
    verificationKey: Uint8Array;
}
interface MsgpackVkAsFields {
    verification_key: Uint8Array;
}
export interface VkAsFieldsResponse {
    fields: Fr[];
}
interface MsgpackVkAsFieldsResponse {
    fields: Uint8Array[];
}
export interface CircuitComputeVk {
    circuit: CircuitInputNoVK;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitComputeVk {
    circuit: MsgpackCircuitInputNoVK;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint256T[];
    hash: Uint8Array;
}
interface MsgpackCircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
    hash: Uint8Array;
}
export interface CircuitInfoResponse {
    numGates: number;
    numGatesDyadic: number;
    numAcirOpcodes: number;
    gatesPerOpcode: number[];
}
interface MsgpackCircuitInfoResponse {
    num_gates: number;
    num_gates_dyadic: number;
    num_acir_opcodes: number;
    gates_per_opcode: number[];
}
export interface CircuitInput {
    name: string;
    bytecode: Uint8Array;
    verificationKey: Uint8Array;
}
interface MsgpackCircuitInput {
    name: string;
    bytecode: Uint8Array;
    verification_key: Uint8Array;
}
export interface CircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
interface MsgpackCircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
export interface CircuitProve {
    circuit: CircuitInput;
    witness: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitProve {
    circuit: MsgpackCircuitInput;
    witness: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitProveResponse {
    publicInputs: Uint256T[];
    proof: Uint256T[];
    vk: CircuitComputeVkResponse;
}
interface MsgpackCircuitProveResponse {
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    vk: MsgpackCircuitComputeVkResponse;
}
export interface CircuitStats {
    circuit: CircuitInput;
    includeGatesPerOpcode: boolean;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitStats {
    circuit: MsgpackCircuitInput;
    include_gates_per_opcode: boolean;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerify {
    verificationKey: Uint8Array;
    publicInputs: Uint256T[];
    proof: Uint256T[];
    settings: ProofSystemSettings;
}
interface MsgpackCircuitVerify {
    verification_key: Uint8Array;
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerifyResponse {
    verified: boolean;
}
interface MsgpackCircuitVerifyResponse {
    verified: boolean;
}
export interface CircuitWriteSolidityVerifier {
    verificationKey: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitWriteSolidityVerifier {
    verification_key: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitWriteSolidityVerifierResponse {
    solidityCode: string;
}
interface MsgpackCircuitWriteSolidityVerifierResponse {
    solidity_code: string;
}
export interface ClientIvcAccumulate {
    witness: Uint8Array;
}
interface MsgpackClientIvcAccumulate {
    witness: Uint8Array;
}
export interface ClientIvcAccumulateResponse {
}
interface MsgpackClientIvcAccumulateResponse {
}
export interface ClientIvcCheckPrecomputedVk {
    circuit: CircuitInput;
}
interface MsgpackClientIvcCheckPrecomputedVk {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actualVk: Uint8Array;
}
interface MsgpackClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actual_vk: Uint8Array;
}
export interface ClientIvcComputeIvcVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeIvcVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
interface MsgpackClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
export interface ClientIvcComputeStandaloneVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeStandaloneVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Fr[];
}
interface MsgpackClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
}
export interface ClientIvcLoad {
    circuit: CircuitInput;
}
interface MsgpackClientIvcLoad {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcLoadResponse {
}
interface MsgpackClientIvcLoadResponse {
}
export interface ClientIVCProof {
    megaProof: Fr[];
    goblinProof: GoblinProof;
}
interface MsgpackClientIVCProof {
    mega_proof: Uint8Array[];
    goblin_proof: MsgpackGoblinProof;
}
export interface ClientIvcProve {
}
interface MsgpackClientIvcProve {
}
export interface ClientIvcProveResponse {
    proof: ClientIVCProof;
}
interface MsgpackClientIvcProveResponse {
    proof: MsgpackClientIVCProof;
}
export interface ClientIvcStart {
    numCircuits: number;
}
interface MsgpackClientIvcStart {
    num_circuits: number;
}
export interface ClientIvcStartResponse {
}
interface MsgpackClientIvcStartResponse {
}
export interface ClientIvcStats {
    circuit: CircuitInputNoVK;
    includeGatesPerOpcode: boolean;
}
interface MsgpackClientIvcStats {
    circuit: MsgpackCircuitInputNoVK;
    include_gates_per_opcode: boolean;
}
export interface ClientIvcStatsResponse {
    acirOpcodes: number;
    circuitSize: number;
    gatesPerOpcode: number[];
}
interface MsgpackClientIvcStatsResponse {
    acir_opcodes: number;
    circuit_size: number;
    gates_per_opcode: number[];
}
export interface ClientIvcVerify {
    proof: ClientIVCProof;
    vk: Uint8Array;
}
interface MsgpackClientIvcVerify {
    proof: MsgpackClientIVCProof;
    vk: Uint8Array;
}
export interface ClientIvcVerifyResponse {
    valid: boolean;
}
interface MsgpackClientIvcVerifyResponse {
    valid: boolean;
}
export interface ECCVMProof {
    preIpaProof: Fr[];
    ipaProof: Fr[];
}
interface MsgpackECCVMProof {
    pre_ipa_proof: Uint8Array[];
    ipa_proof: Uint8Array[];
}
export interface GoblinProof {
    mergeProof: Fr[];
    eccvmProof: ECCVMProof;
    translatorProof: Fr[];
}
interface MsgpackGoblinProof {
    merge_proof: Uint8Array[];
    eccvm_proof: MsgpackECCVMProof;
    translator_proof: Uint8Array[];
}
export interface ProofSystemSettings {
    ipaAccumulation: boolean;
    oracleHashType: string;
    disableZk: boolean;
    optimizedSolidityVerifier: boolean;
}
interface MsgpackProofSystemSettings {
    ipa_accumulation: boolean;
    oracle_hash_type: string;
    disable_zk: boolean;
    optimized_solidity_verifier: boolean;
}
export interface VkAsFields {
    verificationKey: Uint8Array;
}
interface MsgpackVkAsFields {
    verification_key: Uint8Array;
}
export interface VkAsFieldsResponse {
    fields: Fr[];
}
interface MsgpackVkAsFieldsResponse {
    fields: Uint8Array[];
}
export declare function toCircuitComputeVk(o: MsgpackCircuitComputeVk): CircuitComputeVk;
export declare function fromCircuitComputeVk(o: CircuitComputeVk): MsgpackCircuitComputeVk;
export declare function toCircuitComputeVkResponse(o: MsgpackCircuitComputeVkResponse): CircuitComputeVkResponse;
export declare function fromCircuitComputeVkResponse(o: CircuitComputeVkResponse): MsgpackCircuitComputeVkResponse;
export declare function toCircuitInfoResponse(o: MsgpackCircuitInfoResponse): CircuitInfoResponse;
export declare function fromCircuitInfoResponse(o: CircuitInfoResponse): MsgpackCircuitInfoResponse;
export declare function toCircuitInput(o: MsgpackCircuitInput): CircuitInput;
export declare function fromCircuitInput(o: CircuitInput): MsgpackCircuitInput;
export declare function toCircuitInputNoVK(o: MsgpackCircuitInputNoVK): CircuitInputNoVK;
export declare function fromCircuitInputNoVK(o: CircuitInputNoVK): MsgpackCircuitInputNoVK;
export declare function toCircuitProve(o: MsgpackCircuitProve): CircuitProve;
export declare function fromCircuitProve(o: CircuitProve): MsgpackCircuitProve;
export declare function toCircuitProveResponse(o: MsgpackCircuitProveResponse): CircuitProveResponse;
export declare function fromCircuitProveResponse(o: CircuitProveResponse): MsgpackCircuitProveResponse;
export declare function toCircuitStats(o: MsgpackCircuitStats): CircuitStats;
export declare function fromCircuitStats(o: CircuitStats): MsgpackCircuitStats;
export declare function toCircuitVerify(o: MsgpackCircuitVerify): CircuitVerify;
export declare function fromCircuitVerify(o: CircuitVerify): MsgpackCircuitVerify;
export declare function toCircuitVerifyResponse(o: MsgpackCircuitVerifyResponse): CircuitVerifyResponse;
export declare function fromCircuitVerifyResponse(o: CircuitVerifyResponse): MsgpackCircuitVerifyResponse;
export declare function toCircuitWriteSolidityVerifier(o: MsgpackCircuitWriteSolidityVerifier): CircuitWriteSolidityVerifier;
export declare function fromCircuitWriteSolidityVerifier(o: CircuitWriteSolidityVerifier): MsgpackCircuitWriteSolidityVerifier;
export declare function toCircuitWriteSolidityVerifierResponse(o: MsgpackCircuitWriteSolidityVerifierResponse): CircuitWriteSolidityVerifierResponse;
export declare function fromCircuitWriteSolidityVerifierResponse(o: CircuitWriteSolidityVerifierResponse): MsgpackCircuitWriteSolidityVerifierResponse;
export declare function toClientIvcAccumulate(o: MsgpackClientIvcAccumulate): ClientIvcAccumulate;
export declare function fromClientIvcAccumulate(o: ClientIvcAccumulate): MsgpackClientIvcAccumulate;
export declare function toClientIvcAccumulateResponse(o: MsgpackClientIvcAccumulateResponse): ClientIvcAccumulateResponse;
export declare function fromClientIvcAccumulateResponse(o: ClientIvcAccumulateResponse): MsgpackClientIvcAccumulateResponse;
export declare function toClientIvcCheckPrecomputedVk(o: MsgpackClientIvcCheckPrecomputedVk): ClientIvcCheckPrecomputedVk;
export declare function fromClientIvcCheckPrecomputedVk(o: ClientIvcCheckPrecomputedVk): MsgpackClientIvcCheckPrecomputedVk;
export declare function toClientIvcCheckPrecomputedVkResponse(o: MsgpackClientIvcCheckPrecomputedVkResponse): ClientIvcCheckPrecomputedVkResponse;
export declare function fromClientIvcCheckPrecomputedVkResponse(o: ClientIvcCheckPrecomputedVkResponse): MsgpackClientIvcCheckPrecomputedVkResponse;
export declare function toClientIvcComputeIvcVk(o: MsgpackClientIvcComputeIvcVk): ClientIvcComputeIvcVk;
export declare function fromClientIvcComputeIvcVk(o: ClientIvcComputeIvcVk): MsgpackClientIvcComputeIvcVk;
export declare function toClientIvcComputeIvcVkResponse(o: MsgpackClientIvcComputeIvcVkResponse): ClientIvcComputeIvcVkResponse;
export declare function fromClientIvcComputeIvcVkResponse(o: ClientIvcComputeIvcVkResponse): MsgpackClientIvcComputeIvcVkResponse;
export declare function toClientIvcComputeStandaloneVk(o: MsgpackClientIvcComputeStandaloneVk): ClientIvcComputeStandaloneVk;
export declare function fromClientIvcComputeStandaloneVk(o: ClientIvcComputeStandaloneVk): MsgpackClientIvcComputeStandaloneVk;
export declare function toClientIvcComputeStandaloneVkResponse(o: MsgpackClientIvcComputeStandaloneVkResponse): ClientIvcComputeStandaloneVkResponse;
export declare function fromClientIvcComputeStandaloneVkResponse(o: ClientIvcComputeStandaloneVkResponse): MsgpackClientIvcComputeStandaloneVkResponse;
export declare function toClientIvcLoad(o: MsgpackClientIvcLoad): ClientIvcLoad;
export declare function fromClientIvcLoad(o: ClientIvcLoad): MsgpackClientIvcLoad;
export declare function toClientIvcLoadResponse(o: MsgpackClientIvcLoadResponse): ClientIvcLoadResponse;
export declare function fromClientIvcLoadResponse(o: ClientIvcLoadResponse): MsgpackClientIvcLoadResponse;
export declare function toClientIVCProof(o: MsgpackClientIVCProof): ClientIVCProof;
export declare function fromClientIVCProof(o: ClientIVCProof): MsgpackClientIVCProof;
export declare function toClientIvcProve(o: MsgpackClientIvcProve): ClientIvcProve;
export declare function fromClientIvcProve(o: ClientIvcProve): MsgpackClientIvcProve;
export declare function toClientIvcProveResponse(o: MsgpackClientIvcProveResponse): ClientIvcProveResponse;
export declare function fromClientIvcProveResponse(o: ClientIvcProveResponse): MsgpackClientIvcProveResponse;
export declare function toClientIvcStart(o: MsgpackClientIvcStart): ClientIvcStart;
export declare function fromClientIvcStart(o: ClientIvcStart): MsgpackClientIvcStart;
export declare function toClientIvcStartResponse(o: MsgpackClientIvcStartResponse): ClientIvcStartResponse;
export declare function fromClientIvcStartResponse(o: ClientIvcStartResponse): MsgpackClientIvcStartResponse;
export declare function toClientIvcStats(o: MsgpackClientIvcStats): ClientIvcStats;
export declare function fromClientIvcStats(o: ClientIvcStats): MsgpackClientIvcStats;
export declare function toClientIvcStatsResponse(o: MsgpackClientIvcStatsResponse): ClientIvcStatsResponse;
export declare function fromClientIvcStatsResponse(o: ClientIvcStatsResponse): MsgpackClientIvcStatsResponse;
export declare function toClientIvcVerify(o: MsgpackClientIvcVerify): ClientIvcVerify;
export declare function fromClientIvcVerify(o: ClientIvcVerify): MsgpackClientIvcVerify;
export declare function toClientIvcVerifyResponse(o: MsgpackClientIvcVerifyResponse): ClientIvcVerifyResponse;
export declare function fromClientIvcVerifyResponse(o: ClientIvcVerifyResponse): MsgpackClientIvcVerifyResponse;
export declare function toECCVMProof(o: MsgpackECCVMProof): ECCVMProof;
export declare function fromECCVMProof(o: ECCVMProof): MsgpackECCVMProof;
export declare function toGoblinProof(o: MsgpackGoblinProof): GoblinProof;
export declare function fromGoblinProof(o: GoblinProof): MsgpackGoblinProof;
export declare function toProofSystemSettings(o: MsgpackProofSystemSettings): ProofSystemSettings;
export declare function fromProofSystemSettings(o: ProofSystemSettings): MsgpackProofSystemSettings;
export declare function toVkAsFields(o: MsgpackVkAsFields): VkAsFields;
export declare function fromVkAsFields(o: VkAsFields): MsgpackVkAsFields;
export declare function toVkAsFieldsResponse(o: MsgpackVkAsFieldsResponse): VkAsFieldsResponse;
export declare function fromVkAsFieldsResponse(o: VkAsFieldsResponse): MsgpackVkAsFieldsResponse;
export interface BbApiBase {
    circuitProve(command: CircuitProve): Promise<CircuitProveResponse>;
    circuitComputeVk(command: CircuitComputeVk): Promise<CircuitComputeVkResponse>;
    circuitStats(command: CircuitStats): Promise<CircuitInfoResponse>;
    circuitVerify(command: CircuitVerify): Promise<CircuitVerifyResponse>;
    clientIvcComputeStandaloneVk(command: ClientIvcComputeStandaloneVk): Promise<ClientIvcComputeStandaloneVkResponse>;
    clientIvcComputeIvcVk(command: ClientIvcComputeIvcVk): Promise<ClientIvcComputeIvcVkResponse>;
    clientIvcStart(command: ClientIvcStart): Promise<ClientIvcStartResponse>;
    clientIvcLoad(command: ClientIvcLoad): Promise<ClientIvcLoadResponse>;
    clientIvcAccumulate(command: ClientIvcAccumulate): Promise<ClientIvcAccumulateResponse>;
    clientIvcProve(command: ClientIvcProve): Promise<ClientIvcProveResponse>;
    clientIvcVerify(command: ClientIvcVerify): Promise<ClientIvcVerifyResponse>;
    vkAsFields(command: VkAsFields): Promise<VkAsFieldsResponse>;
    circuitWriteSolidityVerifier(command: CircuitWriteSolidityVerifier): Promise<CircuitWriteSolidityVerifierResponse>;
    clientIvcCheckPrecomputedVk(command: ClientIvcCheckPrecomputedVk): Promise<ClientIvcCheckPrecomputedVkResponse>;
    clientIvcStats(command: ClientIvcStats): Promise<ClientIvcStatsResponse>;
    destroy(): Promise<void>;
}
export {};
//# sourceMappingURL=api_types.d.ts.map